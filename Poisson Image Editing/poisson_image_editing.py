# -*- coding: utf-8 -*-
"""Poisson Image Editing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L2X-9-yVd8E8AXpoOS5qLo3GXFWUKSjI
"""

import scipy
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import scipy.sparse as sparse
from scipy.sparse.linalg import spsolve
import scipy.signal as signal
from google.colab import files

from google.colab import drive
drive.mount('/content/drive')

cd /content/drive/MyDrive/dir/project6/Poisson_Image

def getIndexes(mask, targetH, targetW, offsetX=0, offsetY=0):
    """ 
    Creates indexes of replacement area in the target image, each pixel in the 
    replacement area gets index starting from 1, other pixels outside the 
    replacement area get 0.

    Args:
    - mask: SrcH * SrcW, logical mask of source image
    - targetH, targetW: int, height and width of target image
    - offsetX, offsetY: int, offset of source image origin in the target image

    Return:
    - indexes: targetH * targetW, indexes of replacement area in target image
    """
    # IMPLEMENT HERE
    # you might find numpy.meshgrid and numpy.arange useful
    mask_H, mask_W = mask.shape
    x, y = np.meshgrid(np.arange(mask_W), np.arange(mask_H))

    # 2. Go from source image coordinates to target image coordinates.
    target_img_x = x[mask>0]
    target_img_y = y[mask>0]

    # 3. Setup indexes.
    idx = np.where(mask>0)
    indexes = np.zeros((targetH,targetW))

    # 4. Apply the offset.
    # Caution: x_offset is for the columns and y_offset is for the rows.
    # Caution: careful if offset goes beynod image edge.
    target_img_x = target_img_x + offsetX
    target_img_y = target_img_y + offsetY

    # 5. Fill in the indexes from 1 to N.
    #indexes[target_img_y, target_img_x] = np.arange(1, target_img_x.size +1)

    # 6. indexes will have a shape same as the target image.
    indexes[target_img_y, target_img_x] = np.arange(1, target_img_x.shape[0] + 1)

    return indexes

def getCoefficientMatrix(indexes):
    """
    Constructs the coefficient matrix (A in Ax=b)
    
    Args: 
    - indexes: targetH * targetW, indexes of replacement area in target image
    
    Return:
    - A: N * N(N is max index), a matrix corresponds to laplacian kernel, 4 on the diagonal and -1 for each neighbor
    """
    # IMPLEMENT HERE
    # Since the coefficient matrix A is by nature sparse. Consider using scipy.sparse.csr_matrix to represent A to save space

    #Define matrix A
    n = np.count_nonzero(indexes)
    A = 4 * np.eye(n, dtype= np.int8)

    #Getting indices
    indexes_H, indexes_W = indexes.shape
    indexes_x, indexes_y = np.meshgrid(np.arange(indexes_W), np.arange(indexes_H))
    x = indexes_x[indexes > 0]
    y = indexes_y[indexes > 0]

    y_neighbor = np.arange(n)

    # Get the coordinates for each neighbor (that is within the mask) to place into matrix A.
    #Left neighbor
    left_y = y
    left_x = x - 1
    left_neighbor = indexes[left_y, left_x]
    left_y_neighbor = y_neighbor[left_neighbor > 0]
    left_x_neighbor = (left_neighbor[left_y_neighbor] - 1).astype(dtype = np.int32)

    #Right neighbor
    right_y = y
    right_x = x+1
    right_neighbor = indexes[right_y, right_x]
    right_y_neighbor = y_neighbor[right_neighbor > 0]
    right_x_neighbor = (right_neighbor[right_y_neighbor] - 1).astype(dtype = np.int32)

    #Up neighbor
    up_y = y - 1
    up_x = x
    up_neighbor = indexes[up_y, up_x]
    up_y_neighbor = y_neighbor[up_neighbor > 0]
    up_x_neighbor = (up_neighbor[up_y_neighbor] - 1).astype(dtype = np.int32)

    #down neighbor
    down_y = y + 1
    down_x = x
    down_neighbor = indexes[down_y, down_x]
    down_y_neighbor = y_neighbor[down_neighbor > 0]
    down_x_neighbor = (down_neighbor[down_y_neighbor] - 1).astype(dtype = np.int32)

    #replace those nieghbors with -1
    A[left_y_neighbor, left_x_neighbor] = -1
    A[right_y_neighbor, right_x_neighbor] = -1
    A[up_y_neighbor, up_x_neighbor] = -1
    A[down_y_neighbor, down_x_neighbor] = -1

    #Sparse arr
    A = scipy.sparse.csr_matrix(A)
    return A

def getSolutionVect(indexes, source, target, offsetX, offsetY):
    """
    Constructs the target solution vector (b in Ax=b) 
    
    Args:
    - indexes:  targetH * targetW, indexes of replacement area in target image
    - source, target: source and target image
    - offsetX, offsetY: int, offset of source image origin in the target image

    Returns:
    - solution vector b (for single channel)
    """
    indexes_H, indexes_W = indexes.shape
    indexes_x, indexes_y = np.meshgrid(np.arange(indexes_W), np.arange(indexes_H))
    x = indexes_x[indexes > 0]
    y = indexes_y[indexes > 0]
    
    # IMPLEMENT HERE
    # 1. get Laplacian part of b from source image
    laplacian = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]])
    source_laplacian = scipy.signal.convolve2d(source, laplacian, 'same')
    source_y = y - offsetY
    source_x = x - offsetX
    laplacian_b = source_laplacian[source_y, source_x]

    # 2. get pixel part of b from target image
    n = len(x)
    y_b = np.arange(n)

    #left neighbor
    left_y = y
    left_x = x - 1
    left_neighbor = indexes[left_y, left_x]
    left_y_zero = left_y[left_neighbor == 0]
    left_x_zero = left_x[left_neighbor == 0]
    left_val = target[left_y_zero, left_x_zero]
    left_b = np.zeros(x.shape[0])

    left_b[y_b[left_neighbor == 0]] = left_val
    left_b[y_b[left_neighbor == 0]] = left_val

    #right neighbor
    right_y = y
    right_x = x + 1
    right_neighbor = indexes[right_y, right_x]
    right_y_zero = right_y[right_neighbor == 0]
    right_x_zero = right_x[right_neighbor == 0]
    right_val = target[right_y_zero, right_x_zero]
    right_b = np.zeros(x.shape[0])

    right_b[y_b[right_neighbor == 0]] = right_val
    right_b[y_b[right_neighbor == 0]] = right_val

    #Up
    up_y = y - 1
    up_x = x 
    up_neighbor = indexes[up_y, up_x]
    up_y_zero = up_y[up_neighbor == 0]
    up_x_zero = up_x[up_neighbor == 0]
    up_val = target[up_y_zero, up_x_zero]
    up_b = np.zeros(x.shape[0])

    up_b[y_b[up_neighbor == 0]] = up_val
    up_b[y_b[up_neighbor == 0]] = up_val

    # 3. add two parts together to get b
    down_y = y + 1
    down_x = x 
    down_neighbor = indexes[down_y, down_x]
    down_y_zero = down_y[down_neighbor == 0]
    down_x_zero = down_x[down_neighbor == 0]
    down_val = target[down_y_zero, down_x_zero]
    down_b = np.zeros(x.shape[0])

    down_b[y_b[down_neighbor == 0]] = down_val
    down_b[y_b[down_neighbor == 0]] = down_val

    #Final b: lp_b + left + right + up + down
    b = laplacian_b + left_b + right_b + up_b + down_b

    return b

def solveEqu(A, b):
    """
    Solve the equation Ax = b to get replacement pixels x in the replacement area
    Note: A is a sparse matrix, so we need to use corresponding function to solve it

    Args:
    - A: Laplacian coefficient matrix
    - b: target solution vector

    Returns:
    - x: solution of Ax = b
    """
    # IMPLEMENT HERE
    # you may find scipy.sparse.linalg.spsolve useful to solve equation
    x = scipy.sparse.linalg.spsolve(A, b)
    
    return x

def reconstructImg(indexes, red, green, blue, target):
    """
    Reconstruct the target image with new red, green, blue channel values in the 
    indexes area

    Args:
    - indexes: targetH * targetW, indexes of replacement area in target image
    - red, green, blue: 1 x N, three chanels for replacement pixel values
    - target: target image
    
    Returns:
    - resultImg: reconstructed target image with poisson editing
    """
    # IMPLEMENT HERE
    # 1. get nonzero component in indexes
    indexes_H, indexes_W = indexes.shape
    indexes_x, indexes_y = np.meshgrid(np.arange(indexes_W), np.arange(indexes_H))
    x = indexes_x[indexes > 0]
    y = indexes_y[indexes > 0]

    # 2. stack three channels together with numpy dstack
    three_channels = np.dstack((red, green, blue)).reshape(len(x), 3)


    # 3. copy new pixels in the indexes area to the target image
    target_copy = np.copy(target)
    
    #resultImg = np.zeros((target.shape[0],target.shape[2]))
    target_copy[y,x] = three_channels
    #resultImg = target_copy

    return target_copy



"""### Seamless Cloning Poisson Editing"""

def seamlessCloningPoisson(sourceImg, targetImg, mask, offsetX, offsetY):
    """
    Wrapper function to put all steps together
    
    Args:
    - sourceImg, targetImg: source and targe image
    - mask: logical mask of source image
    - offsetX, offsetY: offset of source image origin in the target image
    
    Returns:
    - ResultImg: result image
    """
    # step 1: index replacement pixels
    indexes = getIndexes(mask, targetImg.shape[0], targetImg.shape[1], offsetX,
                         offsetY)
    # step 2: compute the Laplacian matrix A
    A = getCoefficientMatrix(indexes)

    # step 3: for each color channel, compute the solution vector b
    red, green, blue = [
        getSolutionVect(indexes, sourceImg[:, :, i], targetImg[:, :, i],
                        offsetX, offsetY).T for i in range(3)
    ]

    # step 4: solve for the equation Ax = b to get the new pixels in the replacement area
    new_red, new_green, new_blue = [
        solveEqu(A, channel)
        for channel in [red, green, blue]
    ]

    # step 5: reconstruct the image with new color channel
    resultImg = reconstructImg(indexes, new_red, new_green, new_blue,
                               targetImg)
    return resultImg

src_path = 'Images/source_3.jpg'
src = np.array(Image.open(src_path).convert('RGB'), 'f') / 255
target_path  ='Images/target_3.jpg'
target = np.array(Image.open(target_path).convert('RGB'), 'f') / 255
offsetX = 40
offsetY = 20
mask_path = 'Images/mask_3.bmp'
mask = np.array(Image.open(mask_path)) > 0
result = seamlessCloningPoisson(src, target, mask, offsetX, offsetY)
plt.imshow(result)
plt.show()
cloned = Image.fromarray((np.clip(result, 0, 1) * 255).astype(np.uint8))
cloned.save('cloned.png')
files.download('cloned.png')

"""### Mixing gradient Poisson Editing"""

def getSolutionVectMixing(indexes, source, target, offsetX, offsetY):
    """
    Constructs the target solution vector(b in Ax=b) 
    
    Args:
    - indexes:  targetH * targetW, indexes of replacement area
    - source, target: source and target image
    - offsetX, offsetY: offset of source image origin in the target image

    Returns:
    - solution vector b (for single channel)
    """
    indexes_H, indexes_W = indexes.shape
    indexes_x, indexes_y = np.meshgrid(np.arange(indexes_W), np.arange(indexes_H))
    x = indexes_x[indexes > 0]
    y = indexes_y[indexes > 0]
    # IMPLEMENT HERE
    # almost the same as getSolutionVect, need to change the Laplacian part of b
    laplacian = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]])
    source_laplacian = scipy.signal.convolve2d(source, laplacian, 'same')
    source_y = y - offsetY
    source_x = x - offsetX
    target_laplacian = scipy.signal.convolve2d(target, laplacian, 'same')
    laplacian_s = source_laplacian[source_y, source_x]
    laplacian_t = target_laplacian[y,x]
    laplacian_b = np.where(np.abs(laplacian_s) >= np.abs(laplacian_t), laplacian_s, laplacian_t)

    # 2. get pixel part of b from target image
    n = len(x)
    y_b = np.arange(n)

    #left neighbor
    left_y = y
    left_x = x - 1
    left_neighbor = indexes[left_y, left_x]
    left_y_zero = left_y[left_neighbor == 0]
    left_x_zero = left_x[left_neighbor == 0]
    left_val = target[left_y_zero, left_x_zero]
    left_b = np.zeros(x.shape[0])

    left_b[y_b[left_neighbor == 0]] = left_val
    left_b[y_b[left_neighbor == 0]] = left_val

    #right neighbor
    right_y = y
    right_x = x + 1
    right_neighbor = indexes[right_y, right_x]
    right_y_zero = right_y[right_neighbor == 0]
    right_x_zero = right_x[right_neighbor == 0]
    right_val = target[right_y_zero, right_x_zero]
    right_b = np.zeros(x.shape[0])

    right_b[y_b[right_neighbor == 0]] = right_val
    right_b[y_b[right_neighbor == 0]] = right_val

    #Up
    up_y = y - 1
    up_x = x 
    up_neighbor = indexes[up_y, up_x]
    up_y_zero = up_y[up_neighbor == 0]
    up_x_zero = up_x[up_neighbor == 0]
    up_val = target[up_y_zero, up_x_zero]
    up_b = np.zeros(x.shape[0])

    up_b[y_b[up_neighbor == 0]] = up_val
    up_b[y_b[up_neighbor == 0]] = up_val

    # 3. add two parts together to get b
    down_y = y + 1
    down_x = x 
    down_neighbor = indexes[down_y, down_x]
    down_y_zero = down_y[down_neighbor == 0]
    down_x_zero = down_x[down_neighbor == 0]
    down_val = target[down_y_zero, down_x_zero]
    down_b = np.zeros(x.shape[0])

    down_b[y_b[down_neighbor == 0]] = down_val
    down_b[y_b[down_neighbor == 0]] = down_val

    #Final b: lp_b + left + right + up + down
    b = laplacian_b + left_b + right_b + up_b + down_b
    return b

def PoissonMixing(sourceImg, targetImg, mask, offsetX, offsetY):
    """
    Wrapper function to put all steps together
    
    Args:
    - sourceImg, targetImg: source and target image
    - mask: logical mask of source image
    - offsetX, offsetY: offset of source image origin in the target image
    
    Returns:
    - ResultImg: result image
    """
    # step 1: index replacement pixels
    indexes = getIndexes(mask, targetImg.shape[0], targetImg.shape[1], offsetX,
                         offsetY)
    # step 2: compute the Laplacian matrix A
    A = getCoefficientMatrix(indexes)

    # step 3: for each color channel, compute the solution vector b
    red, green, blue = [
        getSolutionVectMixing(indexes, sourceImg[:, :, i], targetImg[:, :, i],
                        offsetX, offsetY).T for i in range(3)
    ]

    # step 4: solve for the equation Ax = b to get the new pixels in the replacement area
    new_red, new_green, new_blue = [
        solveEqu(A, channel)
        for channel in [red, green, blue]
    ]

    # step 5: reconstruct the image with new color channel
    resultImg = reconstructImg(indexes, new_red, new_green, new_blue,
                               targetImg)
    return resultImg

src_path = 'Images/source_2.jpg'
src = Image.open(src_path).convert('RGB')

src = np.array(src, 'f') / 255
target_path  ='Images/target_2.jpg'
target = Image.open(target_path).convert('RGB')
target = np.array(target, 'f') / 255
offsetX = 10
offsetY = 130
mask_path = 'Images/mask_2.bmp'
mask = Image.open(mask_path)
mask =np.array(mask) > 0
result = PoissonMixing(src, target, mask, offsetX, offsetY)
plt.imshow(result)
plt.show()
mixed = Image.fromarray((np.clip(result, 0, 1) * 255).astype(np.uint8))
mixed.save('mixed.png')
files.download('mixed.png')

"""### Texture Flattening Poisson Editing"""

def getSolutionVectTexture(indexes, target, mask, edges):
    """
    Constructs the target solution vector(b in Ax=b) 
    
    Args:
    - indexes:  targetH * targetW, indexes of replacement area
    - source, target: source and target image
    - offsetX, offsetY: offset of source image origin in the target image

    Returns:
    - solution vector b (for single channel)
    """
    # IMPLEMENT HERE
    # almost the same as getSolutionVect, need to change the Laplacian part of b
    indexes_H, indexes_W = indexes.shape
    indexes_x, indexes_y = np.meshgrid(np.arange(indexes_W), np.arange(indexes_H))
    x = indexes_x[indexes > 0]
    y = indexes_y[indexes > 0]

    laplacian = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]) 
    l = [[0,1,-1]]
    r = [[-1,1,0]]
    d = [[-1],[1],[0]]
    u = [[0],[1],[-1]]
    tl = scipy.signal.convolve2d(target, l)
    tr = scipy.signal.convolve2d(target, r)
    tu = scipy.signal.convolve2d(target, u)    
    td = scipy.signal.convolve2d(target, d)

    #vector
    '''
    tlf = np.where((edges[y,x] == False) & (edges[y,x-1] == False),  0, tl[y,x])
    trf = np.where((edges[y,x] == False) & (edges[y,x-1] == False),  0, tr[y,x])
    tdf = np.where((edges[y,x] == False) & (edges[y+1,x] == False),  0, td[y,x])
    tuf = np.where((edges[y,x] == False) & (edges[y-1,x] == False),  0, tu[y,x])
    laplacian_b = tlf + trf + tuf + tdf
    '''

    '''

    y1,x1 = np.where((edges[y,x] == False) & (edges[y,x-1] == False))
    tl[y1,x1] = 0

    y2,x2 = np.where((edges[y,x] == False) & (edges[y,x-1] == False))
    tr[y2,x2] = 0

    y3,x3 = np.where((edges[y,x] == False) & (edges[y+1,x] == False))
    tu[y3,x3] = 0

    y4,x4 = np.where((edges[y,x] == False) & (edges[y-1,x] == False))
    td[y4,x4] = 0

    laplacian_b = tl[y,x] + tr[y,x] +tu[y,x] + td[y,x]
    '''

    '''
    ll = np.where(np.logical_and(edges[y,x], edges[y,x-1]) == False
    rr = np.where(np.logical_and(edges[y,x], edges[y,x+1]) == False
    uu = p.where(np.logical_and(edges[y,x], edges[y-1,x]) == False
    dd = np.where(np.logical_and(edges[y,x], edges[y+1,x]) == False
    '''
    for i in range(len(x)):

      if edges[y[i],x[i]] == False and edges[y[i],x[i]-1]== False:
        tl[y[i],x[i]] =0
      if edges[y[i],x[i]] == False and edges[y[i],x[i]+1]== False:
        tr[y[i],x[i]] =0
      if edges[y[i],x[i]] == False and edges[y[i]-1,x[i]]== False:
        tu[y[i],x[i]] =0
      if edges[y[i],x[i]] == False and edges[y[i]+1,x[i]]== False:
        td[y[i],x[i]] =0
    laplacian_b = tl[y,x] + tr[y,x] +tu[y,x] + td[y,x]   
    
    n = len(x)
    y_b = np.arange(n)

    #left neighbor
    left_y = y
    left_x = x - 1
    left_neighbor = indexes[left_y, left_x]
    left_y_zero = left_y[left_neighbor == 0]
    left_x_zero = left_x[left_neighbor == 0]
    left_val = target[left_y_zero, left_x_zero]
    left_b = np.zeros(x.shape[0])

    left_b[y_b[left_neighbor == 0]] = left_val
    left_b[y_b[left_neighbor == 0]] = left_val

    #right neighbor
    right_y = y
    right_x = x + 1
    right_neighbor = indexes[right_y, right_x]
    right_y_zero = right_y[right_neighbor == 0]
    right_x_zero = right_x[right_neighbor == 0]
    right_val = target[right_y_zero, right_x_zero]
    right_b = np.zeros(x.shape[0])

    right_b[y_b[right_neighbor == 0]] = right_val
    right_b[y_b[right_neighbor == 0]] = right_val

    #Up
    up_y = y - 1
    up_x = x 
    up_neighbor = indexes[up_y, up_x]
    up_y_zero = up_y[up_neighbor == 0]
    up_x_zero = up_x[up_neighbor == 0]
    up_val = target[up_y_zero, up_x_zero]
    up_b = np.zeros(x.shape[0])

    up_b[y_b[up_neighbor == 0]] = up_val
    up_b[y_b[up_neighbor == 0]] = up_val

    # 3. add two parts together to get b
    down_y = y + 1
    down_x = x 
    down_neighbor = indexes[down_y, down_x]
    down_y_zero = down_y[down_neighbor == 0]
    down_x_zero = down_x[down_neighbor == 0]
    down_val = target[down_y_zero, down_x_zero]
    down_b = np.zeros(x.shape[0])

    down_b[y_b[down_neighbor == 0]] = down_val
    down_b[y_b[down_neighbor == 0]] = down_val
    
    solVectorb = laplacian_b + left_b + right_b + up_b + down_b
    return solVectorb

def PoissonTextureFlattening(targetImg, mask, edges):
    """
    Wrapper function to put all steps together
    
    Args:
    - targetImg: target image
    - mask: logical mask of source image
    - offsetX, offsetY: offset of source image origin in the target image
    
    Returns:
    - ResultImg: result image
    """
    # step 1: index replacement pixels
    indexes = getIndexes(mask, targetImg.shape[0], targetImg.shape[1])
    # step 2: compute the Laplacian matrix A
    A = getCoefficientMatrix(indexes)

    # step 3: for each color channel, compute the solution vector b
    red, green, blue = [
        getSolutionVectTexture(indexes, targetImg[:, :, i], mask, edges).T for i in range(3)
    ]

    # step 4: solve for the equation Ax = b to get the new pixels in the replacement area
    new_red, new_green, new_blue = [
        solveEqu(A, channel)
        for channel in [red, green, blue]
    ]

    # step 5: reconstruct the image with new color channel
    resultImg = reconstructImg(indexes, new_red, new_green, new_blue,
                               targetImg)
    return resultImg

target_path  ='Images/bonobo.jpg'
target = np.array(Image.open(target_path).convert('RGB'), 'f') / 255
from skimage.color import rgb2gray
from skimage import feature
edges = feature.canny(rgb2gray(target))
plt.imshow(edges)
plt.show()
mask_path = 'Images/mask_bonobo.bmp'
mask = np.array(Image.open(mask_path)) > 0
result = PoissonTextureFlattening(target, mask, edges)
plt.imshow(result)
plt.show()
flatten = Image.fromarray((np.clip(result, 0, 1) * 255).astype(np.uint8))
flatten.save('flatten.png')
files.download('flatten.png')